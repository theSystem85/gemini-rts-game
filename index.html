<!DOCTYPE html>
<html>
<head>
<title>RTS MVP</title>
<style>
body, html { 
  margin: 0; 
  overflow: hidden; 
  font-family: monospace;
}
#map {
  position: absolute;
  background-color: #8B4513; /* Land color */
}
.tile {
  width: 32px;
  height: 32px;
  float: left;
  box-sizing: border-box;
  border: 1px solid rgba(0, 0, 0, 0.2); /* Subtle tile borders */
}
.water { background-color: blue; }
.rock { background-color: gray; }
.street { background-color: lightgray; }
.ore { background-color: gold; }
.unit {
  width: 24px;
  height: 24px;
  margin: 4px;
  background-color: green;
  position: relative; /* For health bar positioning */
}
.selected { outline: 2px solid yellow; }
.enemy { background-color: red; }
.factory {
  width: 96px;
  height: 64px;
  background-color: #A9A9A9; /* Factory color */
}
.harvester {
  background-color: violet;
}
.building {
  position: relative; /* For health bar and countdown positioning */
}
.health-bar {
  position: absolute;
  bottom: 0;
  left: 0;
  height: 4px;
  background-color: green;
}
.enemy .health-bar { background-color: red; }
.countdown {
  position: absolute;
  top: 0;
  left: 50%;
  transform: translateX(-50%);
  font-size: 10px;
}
.bullet {
  position: absolute;
  width: 4px;
  height: 4px;
  background-color: black;
  border-radius: 50%;
}
#ui {
  position: absolute;
  top: 10px;
  left: 10px;
  color: white;
}
#occupancy-map {
  position: absolute;
  top: 0;
  left: 0;
  pointer-events: none; /* Allow clicks to pass through */
}
.occupancy-tile {
  width: 32px;
  height: 32px;
  float: left;
  box-sizing: border-box;
  border: 1px solid rgba(255, 0, 0, 0.5); /* Occupancy tile borders */
  opacity: 0.5; /* Semi-transparent */
}
.occupied { background-color: rgba(255, 0, 0, 0.5); }
</style>
</head>
<body>
  <div id="map"></div>
  <div id="ui">
    Money: <span id="money">1000</span><br>
    Wins: <span id="wins">0</span> | Losses: <span id="losses">0</span><br>
    Time: <span id="time">0</span>s<br>
    <button id="start">Start</button>
    <button id="pause" disabled>Pause</button>
    <button id="restart" disabled>Restart</button>
  </div>
  <div id="occupancy-map"></div>

<script>
const mapWidth = 100;
const mapHeight = 100;
const tileSize = 32;
const map = document.getElementById('map');
const ui = document.getElementById('ui');
const moneyDisplay = document.getElementById('money');
const winsDisplay = document.getElementById('wins');
const lossesDisplay = document.getElementById('losses');
const timeDisplay = document.getElementById('time');
const startButton = document.getElementById('start');
const pauseButton = document.getElementById('pause');
const restartButton = document.getElementById('restart');
const occupancyMap = document.getElementById('occupancy-map');
let occupancyGrid = [];
let tiles = [];
let units = [];
let enemyUnits = [];
let bullets = [];
let structures = [];
let enemyStructures = [];
let selectedUnit = null;
let targetMarker = null;
let money = 1000;
let wins = 0;
let losses = 0;
let startTime = 0;
let gamePaused = false;
let showOccupancyMap = false; // Flag to toggle occupancy map visibility

// Initialize map
function initMap() {
  map.style.width = mapWidth * tileSize + 'px';
  map.style.height = mapHeight * tileSize + 'px';
  occupancyMap.style.width = mapWidth * tileSize + 'px';
  occupancyMap.style.height = mapHeight * tileSize + 'px';

  // Generate tiles with connected water, rocks, and streets
  tiles = generateTiles();

  // Create occupancy grid
  occupancyGrid = Array(mapHeight).fill(null).map(() => Array(mapWidth).fill(0));

  for (let y = 0; y < mapHeight; y++) {
    for (let x = 0; x < mapWidth; x++) {
      const tile = document.createElement('div');
      tile.classList.add('tile');
      tile.classList.add(tiles[y][x]); // Add tile type class
      tile.style.left = x * tileSize + 'px';
      tile.style.top = y * tileSize + 'px';
      map.appendChild(tile);

      // Create occupancy map tile
      const occupancyTile = document.createElement('div');
      occupancyTile.classList.add('occupancy-tile');
      occupancyTile.style.left = x * tileSize + 'px';
      occupancyTile.style.top = y * tileSize + 'px';
      occupancyMap.appendChild(occupancyTile);
    }
  }
}

// Generate tiles with connected features
function generateTiles() {
  const newTiles = Array(mapHeight).fill(null).map(() => Array(mapWidth).fill('land'));

  // Generate water
  generateConnectedFeature(newTiles, 'water', 0.3);

  // Generate rocks
  generateConnectedFeature(newTiles, 'rock', 0.2);

  // Generate streets
  generateConnectedFeature(newTiles, 'street', 0.1);

  // Generate ore
  generateOre(newTiles, 0.05);

  return newTiles;
}

// Helper function to generate connected features (water, rocks, streets)
function generateConnectedFeature(tiles, featureType, density) {
  let numFeatures = Math.floor(mapWidth * mapHeight * density);
  let startX = Math.floor(Math.random() * mapWidth);
  let startY = Math.floor(Math.random() * mapHeight);

  while (numFeatures > 0) {
    if (tiles[startY][startX] === 'land') {
      tiles[startY][startX] = featureType;
      numFeatures--;
    }

    // Move to a random neighbor
    const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];
    const randomDir = directions[Math.floor(Math.random() * directions.length)];
    startX = Math.max(0, Math.min(mapWidth - 1, startX + randomDir[0]));
    startY = Math.max(0, Math.min(mapHeight - 1, startY + randomDir[1]));
  }
}

// Helper function to generate ore
function generateOre(tiles, density) {
  for (let y = 0; y < mapHeight; y++) {
    for (let x = 0; x < mapWidth; x++) {
      if (tiles[y][x] === 'land' && Math.random() < density) {
        tiles[y][x] = 'ore';
      }
    }
  }
}

// Initialize game elements
function initGame() {
  units = [];
  enemyUnits = [];
  bullets = [];
  structures = [];
  enemyStructures = [];
  money = 1000;
  startTime = Date.now();
  gamePaused = false;

  // Clear occupancy grid
  for (let y = 0; y < mapHeight; y++) {
    for (let x = 0; x < mapWidth; x++) {
      occupancyGrid[y][x] = 0;
      occupancyMap.children[y * mapWidth + x].classList.remove('occupied');
    }
  }

  // Create player's factory
  createStructure(10, 10, 'factory', false);

  // Create enemy factory
  createStructure(80, 80, 'factory', true);

  // Update UI
  updateUi();
}

// Create a structure (factory)
function createStructure(x, y, type, isEnemy) {
  const structure = {
    x: x,
    y: y,
    type: type,
    isEnemy: isEnemy,
    health: 100,
    width: type === 'factory' ? 3 : 1, // Harvester occupies 1 tile
    height: type === 'factory' ? 2 : 1
  };

  // Add structure to the correct array
  if (isEnemy) {
    enemyStructures.push(structure);
  } else {
    structures.push(structure);
  }

  renderStructure(structure);
}

// Render a structure on the map
function renderStructure(structure) {
  const structureDiv = document.createElement('div');
  structureDiv.classList.add(structure.type);
  structureDiv.classList.add('building');
  if (structure.isEnemy) {
    structureDiv.classList.add('enemy');
  }
  structureDiv.style.left = structure.x * tileSize + 'px';
  structureDiv.style.top = structure.y * tileSize + 'px';
  structureDiv.style.width = structure.width * tileSize + 'px';
  structureDiv.style.height = structure.height * tileSize + 'px';

  // Add health bar
  const healthBar = document.createElement('div');
  healthBar.classList.add('health-bar');
  structureDiv.appendChild(healthBar);

  // Add countdown timer (if factory)
  if (structure.type === 'factory') {
    const countdown = document.createElement('div');
    countdown.classList.add('countdown');
    structureDiv.appendChild(countdown);
  }

  map.appendChild(structureDiv);

  // Update occupancy grid
  for (let y = structure.y; y < structure.y + structure.height; y++) {
    for (let x = structure.x; x < structure.x + structure.width; x++) {
      occupancyGrid[y][x] = 1;
      occupancyMap.children[y * mapWidth + x].classList.add('occupied');
    }
  }
}

// Create a unit (tank or harvester)
function createUnit(x, y, isEnemy, type = 'tank') {
  const unit = {
    x: x,
    y: y,
    isEnemy: isEnemy,
    type: type,
    health: 100,
    speed: type === 'tank' ? 1 : 0.5, // Harvester moves slower
    targetX: null,
    targetY: null,
    moving: false,
    path: [], // Path for A* pathfinding
    armor: type === 'tank' ? 1 : 3, // Harvester has more armor
  };

  // Add unit to the correct array
  if (isEnemy) {
    enemyUnits.push(unit);
  } else {
    units.push(unit);
  }

  renderUnit(unit);
}

// Render a unit on the map
function renderUnit(unit) {
  const unitDiv = document.createElement('div');
  unitDiv.classList.add('unit');
  if (unit.isEnemy) {
    unitDiv.classList.add('enemy');
  }
  if (unit.type === 'harvester') {
    unitDiv.classList.add('harvester');
  }
  unitDiv.style.left = unit.x * tileSize + 'px';
  unitDiv.style.top = unit.y * tileSize + 'px';

  // Add health bar
  const healthBar = document.createElement('div');
  healthBar.classList.add('health-bar');
  unitDiv.appendChild(healthBar);

  map.appendChild(unitDiv);

  // Update occupancy grid
  occupancyGrid[unit.y][unit.x] = 1;
  occupancyMap.children[unit.y * mapWidth + x].classList.add('occupied');
}

// Update game state
function updateGame(timestamp) {
  if (gamePaused) return;

  // Update time
  timeDisplay.textContent = Math.floor((timestamp - startTime) / 1000);

  // Update money
  money += 1; // Increase money over time
  moneyDisplay.textContent = money;

  // Update units
  for (let i = units.length - 1; i >= 0; i--) {
    updateUnit(units[i]);
  }
  for (let i = enemyUnits.length - 1; i >= 0; i--) {
    updateUnit(enemyUnits[i]);
  }

  // Update bullets
  for (let i = bullets.length - 1; i >= 0; i--) {
    updateBullet(bullets[i]);
  }

  // Update structures
  for (let i = structures.length - 1; i >= 0; i--) {
    updateStructure(structures[i]);
  }
  for (let i = enemyStructures.length - 1; i >= 0; i--) {
    updateStructure(enemyStructures[i]);
  }
}

// Update a single unit
function updateUnit(unit) {
  // A* pathfinding (simplified)
  if (unit.targetX !== null && unit.targetY !== null && unit.path.length === 0) {
    unit.path = findPath(unit.x, unit.y, unit.targetX, unit.targetY);
  }

  // Move unit
  if (unit.path.length > 0) {
    const nextTile = unit.path.shift();
    moveUnit(unit, nextTile.x, nextTile.y);
  }

  // Enemy AI (basic)
  if (unit.isEnemy) {
    if (Math.random() < 0.01) { // 1% chance to change target
      const targetStructure = structures[Math.floor(Math.random() * structures.length)];
      unit.targetX = targetStructure.x;
      unit.targetY = targetStructure.y;
    }
  }
}

// Move a unit to a target tile
function moveUnit(unit, targetX, targetY) {
  // Calculate movement speed based on tile type
  let speed = unit.speed;
  const targetTileType = tiles[targetY][targetX];
  if (targetTileType === 'street') {
    speed *= 1.5; // 50% faster on streets
  }

  // Calculate distance to target
  const dx = targetX - unit.x;
  const dy = targetY - unit.y;
  const dist = Math.sqrt(dx * dx + dy * dy);

  // If close enough to target, snap to position
  if (dist < speed) {
    unit.x = targetX;
    unit.y = targetY;
    unit.moving = false;
  } else {
    // Move towards target
    unit.x += dx / dist * speed;
    unit.y += dy / dist * speed;
    unit.moving = true;
  }

  // Update unit's position on the map
  const unitDiv = map.querySelector('.unit' + (unit.isEnemy ? '.enemy' : '') + (unit.type === 'harvester' ? '.harvester' : '') + ':not(.destroyed)');
  if (unitDiv) {
    unitDiv.style.left = unit.x * tileSize + 'px';
    unitDiv.style.top = unit.y * tileSize + 'px';
  }

  // Update occupancy grid
  occupancyGrid[Math.floor(unit.y)][Math.floor(unit.x)] = 1;
  occupancyMap.children[Math.floor(unit.y) * mapWidth + Math.floor(unit.x)].classList.add('occupied');
}

// Find a path using A* algorithm (simplified)
function findPath(startX, startY, endX, endY) {
  // ... (Implementation of A* pathfinding algorithm)
  // For simplicity, this example returns a direct path if possible
  // In a real implementation, you would use A* to find a path around obstacles
  const path = [];
  if (tiles[endY][endX] !== 'water' && tiles[endY][endX] !== 'rock') {
    path.push({ x: endX, y:endY });
  }
  return path;
}

// Update a single bullet
function updateBullet(bullet) {
  // Move bullet
  bullet.x += bullet.dx * bullet.speed;
  bullet.y += bullet.dy * bullet.speed;

  // Update bullet's position on the map
  bullet.div.style.left = bullet.x * tileSize + 'px';
  bullet.div.style.top = bullet.y * tileSize + 'px';

  // Check for collision with units or structures
  checkBulletCollision(bullet);
}

// Check if a bullet has collided with any units or structures
function checkBulletCollision(bullet) {
  // ... (Implementation of collision detection)
  // If collision detected, damage the unit/structure and remove the bullet
}

// Update a single structure
function updateStructure(structure) {
  // Update health bar
  const structureDiv = map.querySelector('.building' + (structure.isEnemy ? '.enemy' : '') + ':not(.destroyed)');
  if (structureDiv) {
    const healthBar = structureDiv.querySelector('.health-bar');
    healthBar.style.width = structure.health + '%';

    // Check for destruction
    if (structure.health <= 0) {
      structureDiv.classList.add('destroyed');
      // ... (Implementation of destruction animation and sound effect)

      // Update occupancy grid
      for (let y = structure.y; y < structure.y + structure.height; y++) {
        for (let x = structure.x; x < structure.x + structure.width; x++) {
          occupancyGrid[y][x] = 0;
          occupancyMap.children[y * mapWidth + x].classList.remove('occupied');
        }
      }

      // Check for victory/defeat condition
      if (structure.isEnemy) {
        wins++;
        winsDisplay.textContent = wins;
        alert('You win!');
        resetGame();
      } else {
        losses++;
        lossesDisplay.textContent = losses;
        alert('You lose!');
        resetGame();
      }
    }
  }
}

// Update UI elements
function updateUi() {
  moneyDisplay.textContent = money;
  winsDisplay.textContent = wins;
  lossesDisplay.textContent = losses;
  timeDisplay.textContent = 0;
}

// Reset game state
function resetGame() {
  // ... (Implementation of game reset)
}

// Handle user input
function handleInput(event) {
  if (gamePaused) return;

  const mapRect = map.getBoundingClientRect();
  const x = Math.floor((event.clientX - mapRect.left) / tileSize);
  const y = Math.floor((event.clientY - mapRect.top) / tileSize);

  if (event.type === 'mousedown') {
    if (event.button === 2) { // Right-click: Start map scrolling
      map.startX = event.clientX - map.offsetLeft;
      map.startY = event.clientY - map.offsetTop;
      document.addEventListener('mousemove', handleMapDrag);
      document.addEventListener('mouseup', stopMapDrag);
    } else if (event.button === 0) { // Left-click: Unit/structure selection, movement, attack
      const clickedUnit = units.find(unit => Math.floor(unit.x) === x && Math.floor(unit.y) === y);
      const clickedEnemyUnit = enemyUnits.find(unit => Math.floor(unit.x) === x && Math.floor(unit.y) === y);
      const clickedStructure = structures.find(structure => 
        x >= structure.x && x < structure.x + structure.width &&
        y >= structure.y && y < structure.y + structure.height
      );
      const clickedEnemyStructure = enemyStructures.find(structure => 
        x >= structure.x && x < structure.x + structure.width &&
        y >= structure.y && y < structure.y + structure.height
      );

      if (clickedUnit) { // Select unit
        selectUnit(clickedUnit);
      } else if (clickedEnemyUnit) { // Attack enemy unit
        if (selectedUnit) {
          attackTarget(selectedUnit, clickedEnemyUnit);
        }
      } else if (clickedStructure) { // Select structure (if needed)
        // ... (Implementation for selecting structures)
      } else if (clickedEnemyStructure) { // Attack enemy structure
        if (selectedUnit) {
          attackTarget(selectedUnit, clickedEnemyStructure);
        }
      } else { // Move selected unit
        if (selectedUnit) {
          moveSelectedUnit(x, y);
        }
      }
    }
  }
}

// Select a unit
function selectUnit(unit) {
  if (selectedUnit) {
    selectedUnit.div.classList.remove('selected');
  }
  selectedUnit = unit;
  selectedUnit.div.classList.add('selected');
}

// Move the selected unit to a target tile
function moveSelectedUnit(x, y) {
  selectedUnit.targetX = x;
  selectedUnit.targetY = y;
  selectedUnit.path = findPath(selectedUnit.x, selectedUnit.y, x, y);

  // Show target marker
  if (!targetMarker) {
    targetMarker = document.createElement('div');
    targetMarker.style.position = 'absolute';
    targetMarker.style.width = tileSize + 'px';
    targetMarker.style.height = tileSize + 'px';
    targetMarker.style.backgroundColor = 'rgba(255, 255, 0, 0.5)';
    map.appendChild(targetMarker);
  }
  targetMarker.style.left = x * tileSize + 'px';
  targetMarker.style.top = y * tileSize + 'px';
}

// Attack a target with the selected unit
function attackTarget(unit, target) {
  // ... (Implementation for attacking units/structures)
}

// Handle map dragging
function handleMapDrag(event) {
  const newX = event.clientX - map.startX;
  const newY = event.clientY - map.startY;
  map.style.left = newX + 'px';
  map.style.top = newY + 'px';

  // Keep map within boundaries
  const mapRect = map.getBoundingClientRect();
  if (mapRect.left > 0) {
    map.style.left = '0px';
  } else if (mapRect.right < window.innerWidth) {
    map.style.left = window.innerWidth - mapRect.width + 'px';
  }
  if (mapRect.top > 0) {
    map.style.top = '0px';
  } else if (mapRect.bottom < window.innerHeight) {
    map.style.top = window.innerHeight - mapRect.height + 'px';
  }
}

// Stop map dragging
function stopMapDrag() {
  document.removeEventListener('mousemove', handleMapDrag);
  document.removeEventListener('mouseup', stopMapDrag);
}

// Initialize game
initMap();
initGame();

// Game loop
let lastTimestamp = 0;
function gameLoop(timestamp) {
  if (!gamePaused) {
    const deltaTime = timestamp - lastTimestamp;
    lastTimestamp = timestamp;

    updateGame(timestamp);
  }

  requestAnimationFrame(gameLoop);
}

// Start game
function startGame() {
  startButton.disabled = true;
  pauseButton.disabled = false;
  restartButton.disabled = false;
  startTime = Date.now();
  gamePaused = false;
  gameLoop(); // Start the game loop
}

// Pause game
function pauseGame() {
  gamePaused = true;
  pauseButton.disabled = true;
  startButton.disabled = false;
}

// Reset game
function resetGame() {
  // Clear existing units, structures, bullets, etc.
  units = [];
  enemyUnits = [];
  bullets = [];
  structures = [];
  enemyStructures = [];
  selectedUnit = null;
  if (targetMarker) {
    map.removeChild(targetMarker);
    targetMarker = null;
  }

  // Clear the map
  map.innerHTML = '';
  occupancyMap.innerHTML = '';

  // Re-initialize the map and game elements
  initMap();
  initGame();

  // Reset UI
  startButton.disabled = false;
  pauseButton.disabled = true;
  restartButton.disabled = true;
  updateUi();
}

// Event listeners
startButton.addEventListener('click', startGame);
pauseButton.addEventListener('click', pauseGame);
restartButton.addEventListener('click', resetGame);

document.addEventListener('keydown', (event) => {
  if (event.key === 'o') {
    showOccupancyMap = !showOccupancyMap;
    occupancyMap.style.display = showOccupancyMap ? 'block' : 'none';
  } else if (event.key === 'h') {
    // Show help alert with controls
    alert('Controls:\n' +
          'Right-click and drag: Scroll map\n' +
          'Left-click on unit: Select unit\n' +
          'Left-click on tile: Move selected unit\n' +
          'Left-click on enemy unit/structure: Attack with selected unit\n' +
          'O key: Toggle occupancy map overlay\n' +
          'H key: Show this help');
  }
});

// ... (Add more event listeners for user input)
</script>

</body>
</html>