<!DOCTYPE html>
<html>
<head>
    <title>RTS Game MVP</title>
    <style>
        * { margin: 0; padding: 0; }
        body, html { height: 100%; overflow: hidden; }
        #game-container {
            display: flex;
            height: 100vh;
            background: #111;
        }
        #sidebar {
            width: 200px;
            background: #222;
            color: white;
            padding: 10px;
            font-family: Arial, sans-serif;
            font-size: 14px;
        }
        #game-canvas { flex-grow: 1; }
        #minimap-container {
            width: 180px;
            height: 180px;
            background: #333;
            margin-top: 10px;
            position: relative;
        }
        #minimap { width: 100%; height: 100%; }
        #viewport-rect {
            position: absolute;
            border: 1px solid white;
            pointer-events: none;
        }
        select, button {
            width: 100%;
            margin: 5px 0;
            padding: 5px;
            background: #333;
            color: white;
            border: 1px solid #555;
        }
        button:hover { background: #444; }
        #unit-stats { margin-top: 10px; font-size: 12px; white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="sidebar">
            <div>Money: $<span id="money">5000</span></div>
            <div>Time: <span id="time">0</span>s</div>
            <div>Wins: <span id="wins">0</span></div>
            <div>Losses: <span id="losses">0</span></div>
            <select id="unit-type">
                <option value="tank">Tank ($1000)</option>
                <option value="rocket">Rocket Tank ($2000)</option>
                <option value="harvester">Harvester ($500)</option>
            </select>
            <button id="produce-btn">Produce (<span id="progress">0%</span>)</button>
            <div id="minimap-container">
                <canvas id="minimap"></canvas>
                <div id="viewport-rect"></div>
            </div>
            <div id="unit-stats">Selected Units: 0</div>
        </div>
        <canvas id="game-canvas"></canvas>
    </div>

    <script>
        // Core Constants
        const TILE_SIZE = 32;
        const SIDEBAR_WIDTH = 200;
        const GRID_WIDTH = Math.floor((window.innerWidth - SIDEBAR_WIDTH) / TILE_SIZE);
        const GRID_HEIGHT = Math.floor(window.innerHeight / TILE_SIZE);
        const TANK_FIRE_RANGE = 5;
        const PROJECTILE_SPEED = 3;

        // DOM Elements
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const minimap = document.getElementById('minimap');
        const minimapCtx = minimap.getContext('2d');

        // Tile Types Definition
        const TILES = {
            LAND: { color: '#A0522D', passable: true, speed: 1 },
            WATER: { color: '#1E90FF', passable: false, speed: 0 },
            ROCK: { color: '#808080', passable: false, speed: 0 },
            STREET: { color: '#D3D3D3', passable: true, speed: 2 },
            ORE: { color: '#FFD700', passable: true, speed: 1 },
            BUILDING: { color: '#666', passable: false, speed: 0 }
        };

        // Unit Types Definition
        const UNIT_TYPES = {
            tank: { cost: 1000, speed: 1, armor: 100, range: TANK_FIRE_RANGE, damage: 20, homing: false },
            rocket: { cost: 2000, speed: 1, armor: 100, range: TANK_FIRE_RANGE * 2, damage: 30, homing: true },
            harvester: { cost: 500, speed: 0.5, armor: 300, capacity: 5, range: 0, damage: 0, homing: false }
        };

        // Game State Object
        let game = {
            money: 5000,
            time: 0,
            wins: 0,
            losses: 0,
            grid: [],
            units: [],
            factories: [],
            projectiles: [],
            camera: { x: 0, y: 0 },
            selectedUnits: [],
            dragging: false,
            dragStart: { x: 0, y: 0 },
            scrollVelocity: { x: 0, y: 0 },
            mouse: { x: 0, y: 0 },
            audioContext: new (window.AudioContext || window.webkitAudioContext)()
        };

        // Initialization Function
        function init() {
            configureCanvas();
            generateMap();
            placeFactories();
            updateStreetCorridor();
            setupInputHandlers();
            startGameLoops();
        }

        // Configure Canvas Size
        function configureCanvas() {
            canvas.width = window.innerWidth - SIDEBAR_WIDTH;
            canvas.height = window.innerHeight;
            minimap.width = 180;
            minimap.height = 180;
        }

        // Generate Game Map
        function generateMap() {
            initializeGrid();
            addTerrainFeatures();
        }

        // Initialize Grid with Default Land Tiles
        function initializeGrid() {
            game.grid = Array(GRID_HEIGHT).fill().map(() => 
                Array(GRID_WIDTH).fill().map(() => ({ type: 'LAND', occupied: false }))
            );
        }

        // Add Terrain Features with Connected Patterns
        function addTerrainFeatures() {
            for (let i = 0; i < 5; i++) {
                const x = Math.floor(Math.random() * GRID_WIDTH);
                const y = Math.floor(Math.random() * GRID_HEIGHT);
                floodFillWater(x, y);
            }
            for (let i = 0; i < 5; i++) {
                const x = Math.floor(Math.random() * GRID_WIDTH);
                const y = Math.floor(Math.random() * GRID_HEIGHT);
                floodFillRock(x, y);
            }
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    if (game.grid[y][x].type === 'LAND' && Math.random() < 0.05) {
                        game.grid[y][x].type = 'ORE';
                    }
                }
            }
        }

        // Flood Fill for Water Clusters
        function floodFillWater(x, y) {
            if (x < 0 || x >= GRID_WIDTH || y < 0 || y >= GRID_HEIGHT || game.grid[y][x].type !== 'LAND') return;
            game.grid[y][x].type = 'WATER';
            const dx = [-1, 0, 1, 0];
            const dy = [0, 1, 0, -1];
            for (let i = 0; i < 4; i++) {
                const nx = x + dx[i];
                const ny = y + dy[i];
                if (Math.random() < 0.5) floodFillWater(nx, ny);
            }
        }

        // Flood Fill for Rock Clusters
        function floodFillRock(x, y) {
            if (x < 0 || x >= GRID_WIDTH || y < 0 || y >= GRID_HEIGHT || game.grid[y][x].type !== 'LAND') return;
            game.grid[y][x].type = 'ROCK';
            const dx = [-1, 0, 1, 0];
            const dy = [0, 1, 0, -1];
            for (let i = 0; i < 4; i++) {
                const nx = x + dx[i];
                const ny = y + dy[i];
                if (Math.random() < 0.5) floodFillRock(nx, ny);
            }
        }

        // Place Initial Factories
        function placeFactories() {
            createPlayerFactory();
            createEnemyFactory();
            markFactoryTiles();
        }

        // Create Player Factory
        function createPlayerFactory() {
            game.factories.push({
                x: 5, y: 5, w: 3, h: 2, health: 1000, owner: 'player', producing: null, progress: 0
            });
        }

        // Create Enemy Factory
        function createEnemyFactory() {
            game.factories.push({
                x: GRID_WIDTH - 8, y: GRID_HEIGHT - 7, w: 3, h: 2, health: 1000, owner: 'enemy', producing: null, progress: 0, money: 5000
            });
        }

        // Mark Factory Tiles as Buildings
        function markFactoryTiles() {
            game.factories.forEach(factory => {
                for (let y = factory.y; y < factory.y + factory.h; y++) {
                    for (let x = factory.x; x < factory.x + factory.w; x++) {
                        if (isWithinGrid(x, y)) markTileAsBuilding(x, y);
                    }
                }
            });
        }

        // Check if Coordinates are Within Grid
        function isWithinGrid(x, y) {
            return x >= 0 && x < GRID_WIDTH && y >= 0 && y < GRID_HEIGHT;
        }

        // Set Tile as Building
        function markTileAsBuilding(x, y) {
            game.grid[y][x].type = 'BUILDING';
            game.grid[y][x].occupied = true;
        }

        // Update Street Corridor Between Factories
        function updateStreetCorridor() {
            const playerFactory = game.factories[0];
            const enemyFactory = game.factories[1];
            const startX = playerFactory.x + 1;
            const endX = enemyFactory.x + 1;
            const midY = Math.floor(GRID_HEIGHT / 2);
            drawHorizontalStreet(startX, endX, midY);
            drawVerticalStreetToPlayer(startX, midY, playerFactory.y);
            drawVerticalStreetToEnemy(endX, midY, enemyFactory.y);
        }

        // Draw Horizontal Street Segment
        function drawHorizontalStreet(startX, endX, y) {
            for (let x = startX; x <= endX; x++) if (isWithinGrid(x, y)) game.grid[y][x].type = 'STREET';
        }

        // Draw Vertical Street to Player Factory
        function drawVerticalStreetToPlayer(x, midY, factoryY) {
            for (let y = midY; y >= factoryY + 2; y--) if (isWithinGrid(x, y)) game.grid[y][x].type = 'STREET';
        }

        // Draw Vertical Street to Enemy Factory
        function drawVerticalStreetToEnemy(x, midY, factoryY) {
            for (let y = midY; y <= factoryY; y++) if (isWithinGrid(x, y)) game.grid[y][x].type = 'STREET';
        }

        // A* Pathfinding Implementation
        function findPath(start, goal) {
            if (!isValidTile(start) || !isValidTile(goal)) return [];
            const openSet = [start];
            const cameFrom = new Map();
            const gScore = new Map([[getTileKey(start), 0]]);
            const fScore = new Map([[getTileKey(start), heuristic(start, goal)]]);

            while (openSet.length > 0) {
                const current = getLowestFScore(openSet, fScore);
                if (isGoalReached(current, goal)) return reconstructPath(cameFrom, current);
                processCurrentTile(current, goal, openSet, cameFrom, gScore, fScore);
            }
            return [];
        }

        // Generate Tile Key for Maps
        function getTileKey(tile) {
            return `${tile.x},${tile.y}`;
        }

        // Check if Goal is Reached
        function isGoalReached(current, goal) {
            return current.x === goal.x && current.y === goal.y;
        }

        // Get Tile with Lowest F Score
        function getLowestFScore(openSet, fScore) {
            return openSet.reduce((a, b) => fScore.get(getTileKey(a)) < fScore.get(getTileKey(b)) ? a : b);
        }

        // Process Current Tile in Pathfinding
        function processCurrentTile(current, goal, openSet, cameFrom, gScore, fScore) {
            openSet.splice(openSet.indexOf(current), 1);
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    const neighbor = { x: current.x + dx, y: current.y + dy };
                    if (!isValidTile(neighbor)) continue;
                    updateNeighborCosts(current, neighbor, goal, openSet, cameFrom, gScore, fScore);
                }
            }
        }

        // Update Costs for Neighboring Tiles
        function updateNeighborCosts(current, neighbor, goal, openSet, cameFrom, gScore, fScore) {
            const cost = game.grid[neighbor.y][neighbor.x].type === 'STREET' ? 0.5 : 1;
            const tentativeG = gScore.get(getTileKey(current)) + cost;
            const key = getTileKey(neighbor);
            if (tentativeG < (gScore.get(key) || Infinity)) {
                cameFrom.set(key, current);
                gScore.set(key, tentativeG);
                fScore.set(key, tentativeG + heuristic(neighbor, goal));
                if (!openSet.some(n => n.x === neighbor.x && n.y === neighbor.y)) openSet.push(neighbor);
            }
        }

        // Heuristic Function for A*
        function heuristic(a, b) {
            return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
        }

        // Reconstruct Path from A* Results
        function reconstructPath(cameFrom, current) {
            const path = [current];
            let key = getTileKey(current);
            while (cameFrom.has(key)) {
                current = cameFrom.get(key);
                path.unshift(current);
                key = getTileKey(current);
            }
            return path;
        }

        // Check if Tile is Valid for Movement
        function isValidTile(pos) {
            return isWithinGrid(pos.x, pos.y) && TILES[game.grid[pos.y][pos.x].type].passable && !game.grid[pos.y][pos.x].occupied;
        }

        // Setup Production Button Listener
        function setupProductionListener() {
            document.getElementById('produce-btn').addEventListener('click', initiateProduction);
        }

        // Initiate Unit Production
        function initiateProduction() {
            const type = document.getElementById('unit-type').value;
            const cost = UNIT_TYPES[type].cost;
            const factory = game.factories[0];
            if (game.money >= cost && !factory.producing) {
                game.money -= cost;
                factory.producing = type;
                factory.progress = 0;
                console.log(`Player started producing ${type} for $${cost}`);
            } else {
                console.warn('Production failed: insufficient funds or factory busy');
            }
        }

        // Spawn Unit from Factory
        function spawnUnit(factory, type) {
            const spawnX = factory.x + 1.5;
            const spawnY = factory.y + factory.h;
            const unit = createUnit(spawnX, spawnY, type, factory.owner);
            adjustUnitPosition(unit);
            game.units.push(unit);
            game.grid[Math.floor(unit.y)][Math.floor(unit.x)].occupied = true;
            console.log(`${factory.owner} spawned ${type} at (${unit.x}, ${unit.y})`);
        }

        // Create Unit Object
        function createUnit(x, y, type, owner) {
            return {
                x, y, type, owner,
                health: UNIT_TYPES[type].armor,
                speed: UNIT_TYPES[type].speed,
                path: [],
                target: null,
                ore: type === 'harvester' ? 0 : undefined,
                mining: false,
                firingCooldown: 0
            };
        }

        // Adjust Unit Position to Avoid Overlap
        function adjustUnitPosition(unit) {
            const gridX = Math.floor(unit.x);
            const gridY = Math.floor(unit.y);
            if (game.grid[gridY][gridX].occupied) offsetUnit(unit, gridX, gridY);
        }

        // Offset Unit if Tile is Occupied
        function offsetUnit(unit, gridX, gridY) {
            const offsets = [[0,1], [1,0], [0,-1], [-1,0], [1,1], [-1,-1], [1,-1], [-1,1]];
            for (let [dx, dy] of offsets) {
                const newX = gridX + dx;
                const newY = gridY + dy;
                if (isValidTile({ x: newX, y: newY })) {
                    unit.x = newX + 0.5;
                    unit.y = newY + 0.5;
                    return;
                }
            }
            console.warn(`No free tile found for unit at (${gridX}, ${gridY})`);
        }

        // Enemy Unit Spawning Logic
        function spawnEnemy() {
            const enemyFactory = game.factories[1];
            if (!enemyFactory) return;
            if (enemyFactory.money >= 500 && !enemyFactory.producing) {
                const type = selectEnemyUnitType();
                enemyFactory.producing = type;
                enemyFactory.progress = 0;
                enemyFactory.money -= UNIT_TYPES[type].cost;
                console.log(`Enemy producing ${type}`);
            }
        }

        // Select Random Enemy Unit Type
        function selectEnemyUnitType() {
            const rand = Math.random();
            return rand < 0.6 ? 'tank' : (rand < 0.85 ? 'rocket' : 'harvester');
        }

        // Update Enemy AI Behavior
        function updateEnemyAI(unit) {
            if (unit.type === 'harvester') {
                manageEnemyHarvester(unit);
            } else {
                manageEnemyCombatUnit(unit);
            }
        }

        // Manage Enemy Harvester Behavior
        function manageEnemyHarvester(unit) {
            if (unit.ore >= UNIT_TYPES.harvester.capacity) {
                setPathToFactory(unit, game.factories[1]);
            } else if (!unit.path.length) {
                setPathToNearestOre(unit);
            }
        }

        // Manage Enemy Combat Unit Behavior
        function manageEnemyCombatUnit(unit) {
            const target = findTarget(unit);
            if (target && distTo(unit, target) <= 10) {
                unit.target = target;
                if (distTo(unit, target) > UNIT_TYPES[unit.type].range) {
                    setPathToTarget(unit, target);
                }
            } else {
                setPathToPlayerFactory(unit);
            }
        }

        // Set Path to Factory for Unloading
        function setPathToFactory(unit, factory) {
            unit.path = findPath(
                { x: Math.floor(unit.x), y: Math.floor(unit.y) },
                { x: factory.x + 1, y: factory.y + 2 }
            );
        }

        // Set Path to Nearest Ore
        function setPathToNearestOre(unit) {
            unit.path = findPath(
                { x: Math.floor(unit.x), y: Math.floor(unit.y) },
                findNearestOre(unit)
            );
        }

        // Set Path to Combat Target
        function setPathToTarget(unit, target) {
            unit.path = findPath(
                { x: Math.floor(unit.x), y: Math.floor(unit.y) },
                { x: Math.floor(target.x), y: Math.floor(target.y) }
            );
        }

        // Set Path to Player Factory
        function setPathToPlayerFactory(unit) {
            unit.path = findPath(
                { x: Math.floor(unit.x), y: Math.floor(unit.y) },
                { x: game.factories[0].x + 1, y: game.factories[0].y + 1 }
            );
        }

        // Ore Spreading Logic
        function spreadOre() {
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    if (game.grid[y][x].type === 'ORE' && Math.random() < 0.06) {
                        spreadOreToAdjacentTile(x, y);
                    }
                }
            }
        }

        // Spread Ore to Adjacent Land Tile
        function spreadOreToAdjacentTile(x, y) {
            const dirs = [[0,1], [1,0], [0,-1], [-1,0]];
            const [dy, dx] = dirs[Math.floor(Math.random() * 4)];
            const ny = y + dy, nx = x + dx;
            if (isWithinGrid(nx, ny) && game.grid[ny][nx].type === 'LAND') {
                game.grid[ny][nx].type = 'ORE';
            }
        }

        // Projectile Line of Sight Check
        function hasClearLineOfSight(fromX, fromY, toX, toY) {
            const dx = Math.abs(toX - fromX);
            const dy = Math.abs(toY - fromY);
            const sx = fromX < toX ? 1 : -1;
            const sy = fromY < toY ? 1 : -1;
            let err = (dx > dy ? dx : -dy) / 2;
            let currentX = fromX;
            let currentY = fromY;

            while (true) {
                if (currentX === toX && currentY === toY) break;
                if (game.grid[currentY][currentX].type === 'ROCK') return false;

                const e2 = err;
                if (e2 > -dx) { err -= dy; currentX += sx; }
                if (e2 < dy) { err += dx; currentY += sy; }
            }
            return true;
        }

        // Start Game Loops and Intervals
        function startGameLoops() {
            setInterval(spreadOre, 90000);
            setInterval(spawnEnemy, 10000);
            setInterval(() => game.time++, 1000);
            requestAnimationFrame(gameLoop);
        }

        // Main Game Loop
        function gameLoop() {
            try {
                updateGameState();
                renderGame();
            } catch (e) {
                console.error('Game loop error:', e);
            }
            requestAnimationFrame(gameLoop);
        }

        // Update Game State
        function updateGameState() {
            updateFactories();
            updateUnits();
            updateProjectiles();
            updateCamera();
            checkGameOver();
            updateUI();
        }

        // Update Factory Production
        function updateFactories() {
            game.factories.forEach(factory => {
                if (factory.producing) {
                    factory.progress += 100 / (3 * 60); // 3 seconds at 60 FPS
                    if (factory.progress >= 100) completeProduction(factory);
                }
            });
        }

        // Complete Unit Production
        function completeProduction(factory) {
            spawnUnit(factory, factory.producing);
            factory.producing = null;
            factory.progress = 0;
        }

        // Update All Units
        function updateUnits() {
            for (let i = game.units.length - 1; i >= 0; i--) {
                const unit = game.units[i];
                if (unit.health <= 0) removeDeadUnit(unit, i);
                else processUnit(unit);
            }
        }

        // Remove Dead Unit
        function removeDeadUnit(unit, index) {
            game.grid[Math.floor(unit.y)][Math.floor(unit.x)].occupied = false;
            game.units.splice(index, 1);
            console.log(`Unit at (${unit.x}, ${unit.y}) destroyed`);
        }

        // Process Individual Unit
        function processUnit(unit) {
            if (unit.owner === 'enemy') updateEnemyAI(unit);
            moveUnit(unit);
            handleHarvesterLogic(unit);
            handleCombatLogic(unit);
        }

        // Move Unit Along Path
        function moveUnit(unit) {
            if (unit.path.length === 0) return;
            const next = unit.path[0];
            const dx = next.x - unit.x, dy = next.y - unit.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const speed = TILES[game.grid[Math.floor(unit.y)][Math.floor(unit.x)].type].speed * unit.speed;
            if (dist < speed / 60) snapToNextTile(unit, next);
            else interpolateMovement(unit, dx, dy, dist, speed);
        }

        // Snap Unit to Next Tile
        function snapToNextTile(unit, next) {
            game.grid[Math.floor(unit.y)][Math.floor(unit.x)].occupied = false;
            unit.x = next.x;
            unit.y = next.y;
            game.grid[Math.floor(unit.y)][Math.floor(unit.x)].occupied = true;
            unit.path.shift();
        }

        // Interpolate Unit Movement
        function interpolateMovement(unit, dx, dy, dist, speed) {
            unit.x += (dx / dist) * speed / 60;
            unit.y += (dy / dist) * speed / 60;
        }

        // Handle Harvester Logic
        function handleHarvesterLogic(unit) {
            if (unit.type !== 'harvester') return;
            if (unit.ore >= UNIT_TYPES.harvester.capacity) returnToFactory(unit);
            else if (isOnOreTile(unit) && !unit.mining) startMining(unit);
        }

        // Check if Unit is on Ore Tile
        function isOnOreTile(unit) {
            return game.grid[Math.floor(unit.y)][Math.floor(unit.x)].type === 'ORE';
        }

        // Return Harvester to Factory
        function returnToFactory(unit) {
            const factory = game.factories[unit.owner === 'player' ? 0 : 1];
            if (!unit.path.length) setPathToFactory(unit, factory);
            if (distToFactory(unit) < 1.5 && unit.ore > 0) unloadHarvester(unit);
        }

        // Start Mining Process
        function startMining(unit) {
            unit.mining = true;
            setTimeout(() => {
                if (unit.mining && unit.ore < UNIT_TYPES.harvester.capacity) {
                    unit.ore++;
                    game.grid[Math.floor(unit.y)][Math.floor(unit.x)].type = 'LAND';
                    addFunds(unit.owner, 1000);
                }
                unit.mining = false;
            }, 10000);
        }

        // Add Funds to Owner
        function addFunds(owner, amount) {
            if (owner === 'player') game.money += amount;
            else game.factories[1].money += amount;
        }

        // Unload Harvester Ore
        function unloadHarvester(unit) {
            addFunds(unit.owner, 1000);
            unit.ore = 0;
            unit.path = findPath(
                { x: Math.floor(unit.x), y: Math.floor(unit.y) },
                findNearestOre(unit)
            );
        }

        // Handle Combat Logic with Terrain Check
        function handleCombatLogic(unit) {
            if (unit.type === 'harvester' || unit.firingCooldown > 0) {
                unit.firingCooldown = Math.max(0, unit.firingCooldown - 1);
                return;
            }
            const target = findTarget(unit);
            if (target && distTo(unit, target) <= UNIT_TYPES[unit.type].range) {
                const from = { x: Math.floor(unit.x), y: Math.floor(unit.y) };
                const to = { x: Math.floor(target.x), y: Math.floor(target.y) };
                if (hasClearLineOfSight(from.x, from.y, to.x, to.y)) {
                    fireProjectile(unit, target);
                    unit.firingCooldown = 60;
                    playSoundEffect('shoot');
                }
            }
        }

        // Update Projectiles
        function updateProjectiles() {
            for (let i = game.projectiles.length - 1; i >= 0; i--) {
                const p = game.projectiles[i];
                updateProjectilePosition(p);
                if (isProjectileOutOfBounds(p)) removeProjectile(i);
                else checkProjectileCollision(p, i);
            }
        }

        // Update Projectile Position
        function updateProjectilePosition(p) {
            if (p.homing && p.target.health > 0) adjustHomingProjectile(p);
            p.x += p.vx / 60;
            p.y += p.vy / 60;
        }

        // Adjust Homing Projectile Direction
        function adjustHomingProjectile(p) {
            const dx = p.target.x - p.x, dy = p.target.y - p.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            p.vx = (dx / dist) * PROJECTILE_SPEED;
            p.vy = (dy / dist) * PROJECTILE_SPEED;
        }

        // Check if Projectile is Out of Bounds
        function isProjectileOutOfBounds(p) {
            return p.x < 0 || p.x >= GRID_WIDTH || p.y < 0 || p.y >= GRID_HEIGHT;
        }

        // Remove Projectile
        function removeProjectile(index) {
            game.projectiles.splice(index, 1);
        }

        // Check Projectile Collisions
        function checkProjectileCollision(p, index) {
            game.units.concat(game.factories).forEach(t => {
                if (t.owner !== p.owner && distTo(p, t) < 10 / TILE_SIZE) {
                    applyDamage(t, p);
                    removeProjectile(index);
                }
            });
        }

        // Apply Damage to Target
        function applyDamage(target, projectile) {
            const baseDamage = UNIT_TYPES[projectile.type].damage;
            const damage = baseDamage * (0.8 + Math.random() * 0.4);
            target.health -= damage;
            console.log(`Dealt ${damage.toFixed(1)} damage to ${target.owner}'s ${target.type || 'factory'}`);
        }

        // Update Camera Position
        function updateCamera() {
            game.camera.x += game.scrollVelocity.x;
            game.camera.y += game.scrollVelocity.y;
            game.scrollVelocity.x *= 0.95;
            game.scrollVelocity.y *= 0.95;
            clampCamera();
        }

        // Clamp Camera to Map Boundaries
        function clampCamera() {
            game.camera.x = Math.max(0, Math.min(game.camera.x, GRID_WIDTH * TILE_SIZE - canvas.width));
            game.camera.y = Math.max(0, Math.min(game.camera.y, GRID_HEIGHT * TILE_SIZE - canvas.height));
        }

        // Check for Game Over Conditions
        function checkGameOver() {
            if (game.factories[0]?.health <= 0) {
                game.losses++;
                restartGame();
            }
            if (game.factories[1]?.health <= 0) {
                game.wins++;
                restartGame();
            }
        }

        // Restart Game After Win/Loss
        function restartGame() {
            game.factories = game.factories.filter(f => f.health > 0);
            game.units = [];
            game.projectiles = [];
            init();
        }

        // Update User Interface
        function updateUI() {
            updateMoneyDisplay();
            updateTimeDisplay();
            updateWinsDisplay();
            updateLossesDisplay();
            updateProductionProgress();
            updateUnitStats();
        }

        // Update Money Display
        function updateMoneyDisplay() { document.getElementById('money').textContent = game.money; }
        // Update Time Display
        function updateTimeDisplay() { document.getElementById('time').textContent = game.time; }
        // Update Wins Display
        function updateWinsDisplay() { document.getElementById('wins').textContent = game.wins; }
        // Update Losses Display
        function updateLossesDisplay() { document.getElementById('losses').textContent = game.losses; }
        // Update Production Progress
        function updateProductionProgress() {
            document.getElementById('progress').textContent = 
                game.factories[0].producing ? `${Math.floor(game.factories[0].progress)}%` : '0%';
        }

        // Update Unit Stats Display
        function updateUnitStats() {
            const stats = game.selectedUnits.length > 0 
                ? `Selected Units: ${game.selectedUnits.length}\n` + 
                  game.selectedUnits.map(u => `${u.type}: ${u.health}/${UNIT_TYPES[u.type].armor}`).join('\n')
                : 'Selected Units: 0';
            document.getElementById('unit-stats').textContent = stats;
        }

        // Find Target for Combat
        function findTarget(unit) {
            const targets = game.units.concat(game.factories).filter(t => t.owner !== unit.owner);
            return targets.reduce((closest, t) => 
                distTo(unit, t) < distTo(unit, closest) ? t : closest, 
                { x: Infinity, y: Infinity, health: 1 });
        }

        // Fire Projectile at Target
        function fireProjectile(unit, target) {
            const p = {
                x: unit.x,
                y: unit.y,
                type: unit.type,
                owner: unit.owner,
                target: UNIT_TYPES[unit.type].homing ? target : null,
                homing: UNIT_TYPES[unit.type].homing,
                vx: 0, vy: 0
            };
            calculateProjectileVelocity(p, target);
            game.projectiles.push(p);
        }

        // Calculate Projectile Velocity
        function calculateProjectileVelocity(projectile, target) {
            const dx = target.x - projectile.x, dy = target.y - projectile.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            projectile.vx = (dx / dist) * PROJECTILE_SPEED;
            projectile.vy = (dy / dist) * PROJECTILE_SPEED;
        }

        // Calculate Distance Between Two Points
        function distTo(a, b) {
            return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
        }

        // Calculate Distance to Factory
        function distToFactory(unit) {
            const f = game.factories[unit.owner === 'player' ? 0 : 1];
            return distTo(unit, { x: f.x + 1.5, y: f.y + 1 });
        }

        // Find Nearest Ore Tile
        function findNearestOre(unit) {
            let nearest = { x: Math.floor(unit.x), y: Math.floor(unit.y), dist: Infinity };
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    if (game.grid[y][x].type === 'ORE') {
                        const d = distTo(unit, { x, y });
                        if (d < nearest.dist) nearest = { x, y, dist: d };
                    }
                }
            }
            return nearest;
        }

        // Play Sound Effect (Placeholder)
        function playSoundEffect(type) {
            console.log(`Playing sound: ${type}`);
        }

        // Render Game State
        function renderGame() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            renderGrid();
            renderFactories();
            renderUnits();
            renderProjectiles();
            renderSelectionBox();
            renderMinimap();
        }

        // Render Grid Tiles
        function renderGrid() {
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    const tileX = x * TILE_SIZE - game.camera.x;
                    const tileY = y * TILE_SIZE - game.camera.y;
                    if (!isTileVisible(tileX, tileY)) continue;
                    drawTile(tileX, tileY, game.grid[y][x].type);
                }
            }
        }

        // Check if Tile is Visible
        function isTileVisible(tileX, tileY) {
            return tileX + TILE_SIZE >= 0 && tileX <= canvas.width && tileY + TILE_SIZE >= 0 && tileY <= canvas.height;
        }

        // Draw Individual Tile
        function drawTile(x, y, type) {
            ctx.fillStyle = TILES[type].color;
            ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
            ctx.strokeStyle = 'rgba(0,0,0,0.2)';
            ctx.strokeRect(x, y, TILE_SIZE, TILE_SIZE);
        }

        // Render Factories
        function renderFactories() {
            game.factories.forEach(f => {
                const x = f.x * TILE_SIZE - game.camera.x;
                const y = f.y * TILE_SIZE - game.camera.y;
                drawFactory(x, y, f);
                renderHealthBar(x, y - 10, f.w * TILE_SIZE, f.health, 1000);
                if (f.owner === 'enemy') renderEnemyMoney(x, y - 15, f.money);
            });
        }

        // Draw Factory Sprite
        function drawFactory(x, y, factory) {
            ctx.fillStyle = factory.owner === 'player' ? '#00FF00' : '#FF0000';
            ctx.fillRect(x, y, factory.w * TILE_SIZE, factory.h * TILE_SIZE);
        }

        // Render Health Bar
        function renderHealthBar(x, y, width, health, maxHealth) {
            ctx.fillStyle = 'red';
            ctx.fillRect(x, y, width, 5);
            ctx.fillStyle = 'green';
            ctx.fillRect(x, y, width * (health / maxHealth), 5);
        }

        // Render Enemy Money
        function renderEnemyMoney(x, y, money) {
            ctx.fillStyle = 'white';
            ctx.font = '12px Arial';
            ctx.fillText(`$${money}`, x, y);
        }

        // Render Units with Selection Highlight
        function renderUnits() {
            game.units.forEach(u => {
                const x = u.x * TILE_SIZE - game.camera.x;
                const y = u.y * TILE_SIZE - game.camera.y;
                ctx.fillStyle = u.owner === 'player' ? '#00FFFF' : '#FF00FF';
                ctx.fillRect(x - 8, y - 8, 16, 16);

                if (game.selectedUnits.includes(u)) {
                    ctx.strokeStyle = 'yellow';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x - 8, y - 8, 16, 16);
                }

                renderHealthBar(x - 8, y - 20, 16, u.health, UNIT_TYPES[u.type].armor);
                if (u.type === 'harvester') renderHarvesterProgress(x, y, u);
            });
        }

        // Render Harvester Progress Bar
        function renderHarvesterProgress(x, y, unit) {
            if (unit.mining || unit.ore > 0) {
                ctx.fillStyle = 'yellow';
                ctx.fillRect(x - 8, y + 10, 16 * (unit.ore / UNIT_TYPES.harvester.capacity), 3);
            }
        }

        // Render Projectiles
        function renderProjectiles() {
            game.projectiles.forEach(p => {
                const x = p.x * TILE_SIZE - game.camera.x;
                const y = p.y * TILE_SIZE - game.camera.y;
                drawProjectile(x, y, p);
            });
        }

        // Draw Projectile Sprite
        function drawProjectile(x, y, p) {
            ctx.fillStyle = p.owner === 'player' ? '#FFFF00' : '#FF8000';
            ctx.beginPath();
            ctx.arc(x, y, 3, 0, Math.PI * 2);
            ctx.fill();
        }

        // Render Selection Box
        function renderSelectionBox() {
            if (game.dragging) {
                ctx.strokeStyle = 'white';
                ctx.strokeRect(
                    game.dragStart.x - game.camera.x,
                    game.dragStart.y - game.camera.y,
                    game.mouse.x - game.dragStart.x,
                    game.mouse.y - game.dragStart.y
                );
            }
        }

        // Render Minimap Overview
        function renderMinimap() {
            minimapCtx.clearRect(0, 0, minimap.width, minimap.height);
            const scaleX = minimap.width / (GRID_WIDTH * TILE_SIZE);
            const scaleY = minimap.height / (GRID_HEIGHT * TILE_SIZE);
            drawMinimapTiles(scaleX, scaleY);
            updateViewportRect(scaleX, scaleY);
        }

        // Draw Minimap Tiles
        function drawMinimapTiles(scaleX, scaleY) {
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    minimapCtx.fillStyle = TILES[game.grid[y][x].type].color;
                    minimapCtx.fillRect(x * TILE_SIZE * scaleX, y * TILE_SIZE * scaleY, TILE_SIZE * scaleX, TILE_SIZE * scaleY);
                }
            }
        }

        // Update Minimap Viewport Rectangle
        function updateViewportRect(scaleX, scaleY) {
            const viewRect = document.getElementById('viewport-rect');
            if (viewRect) {
                viewRect.style.left = (game.camera.x * scaleX) + 'px';
                viewRect.style.top = (game.camera.y * scaleY) + 'px';
                viewRect.style.width = (canvas.width * scaleX) + 'px';
                viewRect.style.height = (canvas.height * scaleY) + 'px';
            }
        }

        // Setup All Input Event Handlers
        function setupInputHandlers() {
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('contextmenu', handleRightClick);
            minimap.addEventListener('click', handleMinimapClick);
            setupProductionListener();
        }

        // Handle Mouse Down Event - Selection or Movement
        function handleMouseDown(e) {
            if (e.button === 0) {
                const x = e.offsetX + game.camera.x;
                const y = e.offsetY + game.camera.y;
                
                // Try selecting a unit
                const unit = game.units.find(u => 
                    u.owner === 'player' && 
                    Math.abs(u.x * TILE_SIZE - x) < 16 && 
                    Math.abs(u.y * TILE_SIZE - y) < 16
                );

                if (unit) {
                    // If Shift is held, add to selection; otherwise, select only this unit
                    if (e.shiftKey) {
                        if (!game.selectedUnits.includes(unit)) game.selectedUnits.push(unit);
                    } else {
                        game.selectedUnits = [unit];
                    }
                } else if (game.selectedUnits.length > 0) {
                    // If clicking on empty space with selected units, move them
                    moveUnitsInFormation(e.offsetX, e.offsetY);
                    game.selectedUnits = []; // Deselect after moving
                } else {
                    // Start dragging for multi-selection
                    game.dragging = true;
                    game.dragStart = { x, y };
                }
            } else if (e.button === 2) {
                game.dragStart = { x: e.offsetX, y: e.offsetY };
            }
        }

        // Handle Mouse Movement
        function handleMouseMove(e) {
            game.mouse.x = e.offsetX + game.camera.x;
            game.mouse.y = e.offsetY + game.camera.y;
        }

        // Handle Mouse Up Event - Finalize Selection
        function handleMouseUp(e) {
            if (e.button === 0 && game.dragging) {
                game.dragging = false;
                selectUnitsInRectangle();
            }
        }

        // Select Units Within Selection Rectangle
        function selectUnitsInRectangle() {
            const rect = {
                x: Math.min(game.dragStart.x, game.mouse.x),
                y: Math.min(game.dragStart.y, game.mouse.y),
                w: Math.abs(game.mouse.x - game.dragStart.x),
                h: Math.abs(game.mouse.y - game.dragStart.y)
            };
            game.selectedUnits = game.units.filter(u => 
                u.owner === 'player' &&
                u.x * TILE_SIZE >= rect.x && u.x * TILE_SIZE <= rect.x + rect.w &&
                u.y * TILE_SIZE >= rect.y && u.y * TILE_SIZE <= rect.y + rect.h
            );
        }

        // Handle Right Click for Scrolling Only
        function handleRightClick(e) {
            e.preventDefault();
            scrollMap(e.offsetX, e.offsetY);
        }

        // Move Selected Units in Formation
        function moveUnitsInFormation(offsetX, offsetY) {
            const target = { x: Math.floor((offsetX + game.camera.x) / TILE_SIZE), y: Math.floor((offsetY + game.camera.y) / TILE_SIZE) };
            game.selectedUnits.forEach((u, i) => {
                const offsetX = (i % 3) - 1;
                const offsetY = Math.floor(i / 3) - 1;
                const formationTarget = { x: target.x + offsetX, y: target.y + offsetY };
                u.path = findPath({ x: Math.floor(u.x), y: Math.floor(u.y) }, formationTarget);
            });
        }

        // Scroll Map with Right Click Drag
        function scrollMap(offsetX, offsetY) {
            game.scrollVelocity.x = (game.dragStart.x - offsetX) / 10;
            game.scrollVelocity.y = (game.dragStart.y - offsetY) / 10;
        }

        // Handle Minimap Click for Camera Repositioning
        function handleMinimapClick(e) {
            const scaleX = GRID_WIDTH * TILE_SIZE / minimap.width;
            const scaleY = GRID_HEIGHT * TILE_SIZE / minimap.height;
            game.camera.x = (e.offsetX * scaleX) - canvas.width / 2;
            game.camera.y = (e.offsetY * scaleY) - canvas.height / 2;
            clampCamera();
        }

        // Start the Game
        init();
    </script>
</body>
</html>